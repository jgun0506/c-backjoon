#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>    // srand, rand 함수가 선언된 헤더 파일
#include <string.h>
#include <stdbool.h>
#include <stddef.h>
#include <math.h>



/*
scanf에서의 버퍼와관련해서 주의할점


scanf("%s",s);
scanf("%d",&d);
scanf("%c",&c);
순서대로 입력받는다면 버퍼에 \n를 포함하여 같이 저장됨
ex) asd\n5\nA
이렇게되면 각 서식지정자의 버퍼처리법
%s : 문자를 만날 때까지 ' ', '\n', '\t' 등을 무시하다가, 문자를 만난 이후에는 ' ', '\n', '\t'가 등장하면 종료한다.
%d : 숫자 데이터 아닐 때까지 읽는다
%c : 무조건 한 개의 문자를 읽는다. (당연히 숫자 포함)
즉 %c는 읽을 차례가 되었을때 버퍼값이 개행문자일시(\n와같은)개행문자를 읽어버림
그러니 문자를 읽게하려면" %c"를 해주어 개행문자를 무시해야함 
*/

struct NODE {
    char data;
    struct NODE* next;
    struct NODE* prev;
};

void addnode(struct NODE* target, char data)
{
    struct NODE* new = malloc(sizeof(struct NODE));
    new->data = data;
    
    new->next = target->next;
    new->prev = target;

    if (target->next != NULL)
        target->next->prev = new;
    target->next = new;
}

void removeNode(struct NODE* target)
{
    struct NODE* removeNode = target;
    (removeNode->prev)->next = removeNode->next;
    if (removeNode->next != NULL)
        (removeNode->next)->prev = removeNode->prev;

    free(removeNode);

}


int main(void) {
           

    char s[100001];
    int m;
    
    scanf("%s", s);
    scanf("%d", &m);

    //1.입력받은 문자열로 연결리스트 만들기

    int len = strlen(s);
    

    struct NODE* head = malloc(sizeof(struct NODE));
    head->next = NULL;
    
    struct NODE* cur = head;
    

    for (int i = 0; i < len; i++) {
        addnode(cur, s[i]);
        cur = cur->next;
    }

    for (int i = 0; i < m; i++) {
        char x;
        char a;
        scanf(" %c", &a);//서식지정자에 공백을 넣은이유??

        if (a == 'L') {
            if (cur != head) {
                cur = cur->prev;
            }
        }

        if (a == 'D') {
            if ((cur->next) != NULL) {
                cur = cur->next;
            }
        }
        if (a == 'B') {//현재 커서에 해당하는노드를 삭제

            if (cur != head) {
                struct NODE* cur2 = cur;
                removeNode(cur);
                cur = cur2->prev;
            }
        }

        if (a == 'P') {//현재커서의 뒤에 노드추가

            scanf(" %c", &x);
            addnode(cur, x);
            cur = cur->next;
        }
    }
    cur = head->next;


    while (cur != NULL)
    {
        printf("%c", cur->data);     
        cur = cur->next;          
    }

    cur = head->next;     
    while (cur != NULL)   
    {
        struct NODE* next = cur->next; 
        free(cur);       
        cur = next;      
    }

    free(head);

    return 0;
}
